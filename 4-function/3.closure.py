'''

闭包 closure
条件：出现在嵌套函数中，内层函数引用外层函数的自由变量，外层函数返回的是内层函数的地址！
内层函数引用外层函数定义的变量，那个变量也叫自由变量
闭包比普通的函数多了一个 __closure__ 属性，该属性记录着自由变量的地址
当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用


闭包原理
定义函数只是在内存中开辟了一块空间来存放函数对象以及指令
当函数执行的时候会新开辟一块空间，并生成出局部变量和内部函数对象返回给标识符（内层函数并没有执行）
当返回的内层函数地址返回并被执行的时候，python闭包已经把外层的变量的引用保存放在__closure__中
即使外部函数执行完局部变量被释放，内部函数依然保留了外部函数的引用！！
这就是为什么执行完inc返回inner后依然能找到外部函数变量的原理

nonlocal，指明变量不是本地的局部变量，也不是全局global变量，而是到嵌套函数外层函数的局部变量
nonlocal不能引用全局global变量，因此必须出现在嵌套函数中！

嵌套函数加载局部变量作用域的机制
LEGB机制, local, enclosing, global, build-in
优先用local变量，没有则找外层函数作用域，没有则找global作用域，没有则找build-in，还没有则是NameError异常

    ***** 函数的执行原理 ******
每次函数调用运行是独立的，用局部变量会更安全

堆，是先进先出
栈，是后进先出，栈顶加入数据称为入栈

函数定义，是在heap里创建了函数对象，里面仅包含运行的指令，不包含数据！
函数调用，会在stack中分配函数运行所需要的内存空间，叫做栈帧，每次函数调用都是独立的，执行完都会出栈
数据在heap中创建，栈中标识符指向heap数据
函数执行完后会出栈，如果有返回则保留引用，其他的局部变量都释放
如果执行完函数返回的是另一个新函数，则在stack中变量指向heap中的新函数对象

'''


def inc():
    a = 100
    c = [0]  # 自由变量，执行完inc函数后会被释放，但是inner会引用此变量地址

    def inner():
        print(a)
        c[0] += 1
        return c[0]
    return inner


fn = inc()  # fn指向的是inner函数对象
print(fn.__name__)  # 查看函数名字
print(fn.__closure__)  # 查看闭包，包含的对象地址
print(fn())
print(fn())

print('nonlocal'.center(30, '#'))


def inc():
    a = 0

    def inner():
        nonlocal a
        a += 1
        return a
    return inner


fn = inc()
print(fn.__closure__)
print(fn())
